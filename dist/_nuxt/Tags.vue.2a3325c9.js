import{q as B,s as T,v as E,r as h,x as O,y as S,z as j,A as w,B as k,C as R,e as C,D as U,E as M,d as z,w as A,o as b,a as P,g as H,b as L,t as $,F as q}from"./entry.4faecc06.js";const F=()=>{const i=B();return T()!=="v4"&&console.warn("useStrapi4 is only available for v4"),{find:(c,r,s)=>i(`/${c}`,{method:"GET",params:r,...s}),findOne:(c,r,s,f)=>{typeof r=="object"&&(s=r,r=void 0);const g=[c,r].filter(Boolean).join("/");return i(g,{method:"GET",params:s,...f})},create:(c,r)=>i(`/${c}`,{method:"POST",body:{data:r}}),update:(c,r,s)=>{typeof r=="object"&&(s=r,r=void 0);const f=[c,r].filter(Boolean).join("/");return i(f,{method:"PUT",body:{data:s}})},delete:(c,r)=>{const s=[c,r].filter(Boolean).join("/");return i(s,{method:"DELETE"})}}},m=()=>F();function y(...i){var D;const o=typeof i[i.length-1]=="string"?i.pop():void 0;typeof i[0]!="string"&&i.unshift(o);let[a,n,e={}]=i;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof n!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=R(),v=()=>null,c=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??v,e.getCachedData=e.getCachedData??c,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??E.deep;const r=()=>![null,void 0].includes(e.getCachedData(a));if(!t._asyncData[a]||!e.immediate){(D=t.payload._errors)[a]??(D[a]=null);const u=e.deep?h:O;t._asyncData[a]={data:u(e.getCachedData(a)??e.default()),pending:h(!r()),error:S(t.payload._errors,a),status:h("idle")}}const s={...t._asyncData[a]};s.refresh=s.execute=(u={})=>{if(t._asyncDataPromises[a]){if(u.dedupe===!1)return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((u._initial||t.isHydrating&&u._initial!==!1)&&r())return Promise.resolve(e.getCachedData(a));s.pending.value=!0,s.status.value="pending";const p=new Promise((l,d)=>{try{l(n(t))}catch(x){d(x)}}).then(l=>{if(p.cancelled)return t._asyncDataPromises[a];let d=l;e.transform&&(d=e.transform(l)),e.pick&&(d=I(d,e.pick)),s.data.value=d,s.error.value=null,s.status.value="success"}).catch(l=>{if(p.cancelled)return t._asyncDataPromises[a];s.error.value=l,s.data.value=C(e.default()),s.status.value="error"}).finally(()=>{p.cancelled||(s.pending.value=!1,t.payload.data[a]=s.data.value,s.error.value&&(t.payload._errors[a]=U(s.error.value)),delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=p,t._asyncDataPromises[a]};const f=()=>s.refresh({_initial:!0}),g=e.server!==!1&&t.payload.serverRendered;{const u=M();if(u&&!u._nuxtOnBeforeMountCbs){u._nuxtOnBeforeMountCbs=[];const l=u._nuxtOnBeforeMountCbs;u&&(j(()=>{l.forEach(d=>{d()}),l.splice(0,l.length)}),w(()=>l.splice(0,l.length)))}g&&t.isHydrating&&(s.error.value||r())?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):u&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?u._nuxtOnBeforeMountCbs.push(f):e.immediate&&f(),e.watch&&k(e.watch,()=>s.refresh());const p=t.hook("app:data:refresh",async l=>{(!l||l.includes(a))&&await s.refresh()});u&&w(p)}const _=Promise.resolve(t._asyncDataPromises[a]).then(()=>s);return Object.assign(_,s),_}function I(i,o){const a={};for(const n of o)a[n]=i[n];return a}class G{async get(o){var e,t;const{findOne:a}=m(),{data:n}=await y("posts",()=>a("posts",{filters:{slug:{$eq:o}},populate:{profile:{fields:["name","imgUrl","slug"],populate:{posts:{fields:["title","imgURL","slug"]}}}}}));return{data:(e=n.value)==null?void 0:e.data,meta:(t=n.value)==null?void 0:t.meta}}async previews(){var n,e;const{find:o}=m(),{data:a}=await y("previews",()=>o("posts",{fields:["slug","imgURL","title"]}));return{data:(n=a.value)==null?void 0:n.data,meta:(e=a.value)==null?void 0:e.meta}}async postsInTag(o){var e,t;const{find:a}=m(),{data:n}=await y("postsInTag",()=>a("categories",{filters:{name:{$eq:o}},populate:["posts"]}));return{data:(e=n.value)==null?void 0:e.data[0],meta:(t=n.value)==null?void 0:t.meta}}async getTags(){var n,e;const{find:o}=m(),{data:a}=await y("categories",()=>o("categories"));return{data:(n=a.value)==null?void 0:n.data,meta:(e=a.value)==null?void 0:e.meta}}}const N=new G,V=["href"],J=z({__name:"Tags",async setup(i){let o,a;const n=h(),{data:e}=([o,a]=A(()=>N.getTags()),o=await o,a(),o);return n.value=e,(t,v)=>(b(!0),P(q,null,H(C(e),c=>(b(),P("div",{class:"tags",key:c.id},[L("a",{href:"/tags/"+c.attributes.name},"#"+$(c.attributes.name),9,V)]))),128))}});export{J as _,y as a,N as b,m as u};
